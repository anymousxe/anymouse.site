<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BALLMUNCHER | A Random Game</title>

    <link rel="icon" type="image/png" href="../assets/img/mouseicon.png">

    <meta name="theme-color" content="#ff6b6b">
    <meta name="description" content="This is just a random ass game that robert told me to make. Eat balls, throw balls, munch balls.">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://anymouse.site/ballmuncher">
    <meta property="og:title" content="BALLMUNCHER | A Random Game">
    <meta property="og:description" content="This is just a random ass game that robert told me to make. Eat balls, throw balls, munch balls.">

    <!-- Rate Limiting / DDoS Protection -->
    <script>
        (function() {
            const MAX_ACTIONS = 100;
            const TIME_WINDOW = 10000;
            let actionCount = 0;
            let windowStart = Date.now();
            
            window.rateLimit = function() {
                const now = Date.now();
                if (now - windowStart > TIME_WINDOW) {
                    actionCount = 0;
                    windowStart = now;
                }
                actionCount++;
                return actionCount <= MAX_ACTIONS;
            };
        })();
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;500;700&family=Bangers&display=swap');

        body {
            background: #0a0a0f;
            font-family: 'Space Grotesk', sans-serif;
            overflow: hidden;
            color: #fff;
        }

        /* Main Menu */
        #main-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.5s, transform 0.5s;
        }

        #main-menu.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }

        .menu-confetti {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: fall linear infinite;
        }

        @keyframes fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0.5;
            }
        }

        .menu-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 10vw, 8rem);
            color: #ff6b6b;
            text-shadow: 
                4px 4px 0 #feca57,
                8px 8px 0 #48dbfb,
                12px 12px 0 #ff9ff3;
            letter-spacing: 8px;
            animation: titlePulse 2s ease-in-out infinite;
            text-align: center;
            margin-bottom: 2rem;
        }

        @keyframes titlePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .menu-subtitle {
            font-size: clamp(1rem, 3vw, 1.8rem);
            color: #a0a0a0;
            text-align: center;
            max-width: 600px;
            padding: 0 2rem;
            margin-bottom: 4rem;
            line-height: 1.6;
        }

        .play-btn {
            background: linear-gradient(135deg, #ff6b6b, #feca57);
            border: none;
            padding: 1.5rem 4rem;
            font-size: 2rem;
            font-family: 'Bangers', cursive;
            color: #1a1a2e;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 4px;
            box-shadow: 0 10px 40px rgba(255, 107, 107, 0.4);
            position: relative;
            overflow: hidden;
        }

        .play-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            100% { left: 100%; }
        }

        .play-btn:hover {
            transform: scale(1.1) rotate(-2deg);
            box-shadow: 0 15px 50px rgba(255, 107, 107, 0.6);
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        /* Game UI */
        #game-container {
            width: 100%;
            height: 100vh;
            display: none;
        }

        #game-container.active {
            display: block;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        #crosshair::before {
            width: 2px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #crosshair::after {
            width: 10px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #game-container.active #crosshair {
            display: block;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-family: 'Bangers', cursive;
            font-size: 1.5rem;
            color: #feca57;
            text-shadow: 2px 2px 0 #ff6b6b;
            display: none;
        }

        #game-container.active #hud {
            display: block;
        }

        #instructions {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 1rem 2rem;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #ccc;
            z-index: 100;
            display: none;
            text-align: center;
        }

        #game-container.active #instructions {
            display: block;
        }

        kbd {
            background: #333;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            border: 1px solid #555;
            margin: 0 0.2rem;
        }

        #pause-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
        }

        #pause-menu.active {
            display: flex;
        }

        .pause-btn {
            background: linear-gradient(135deg, #48dbfb, #ff9ff3);
            border: none;
            padding: 1rem 3rem;
            font-size: 1.5rem;
            font-family: 'Bangers', cursive;
            color: #1a1a2e;
            cursor: pointer;
            border-radius: 30px;
            margin: 0.5rem;
            transition: transform 0.2s;
        }

        .pause-btn:hover {
            transform: scale(1.05);
        }

        /* Bite effect overlay */
        .bite-effect {
            position: fixed;
            pointer-events: none;
            z-index: 150;
            font-size: 4rem;
            animation: biteAnim 0.5s forwards;
        }

        @keyframes biteAnim {
            0% { transform: scale(0) rotate(-20deg); opacity: 1; }
            50% { transform: scale(1.5) rotate(10deg); opacity: 1; }
            100% { transform: scale(1) rotate(0deg); opacity: 0; }
        }
    </style>
</head>

<body>
    <!-- Main Menu -->
    <div id="main-menu">
        <div class="menu-confetti" id="menu-confetti"></div>
        <h1 class="menu-title">BALLMUNCHER</h1>
        <p class="menu-subtitle">This is just a random ass game that robert told me to make</p>
        <button class="play-btn" id="play-btn">â–¶ PLAY</button>
    </div>

    <!-- Game Container -->
    <div id="game-container">
        <div id="crosshair"></div>
        <div id="hud">
            <div>ðŸ”´ Balls Eaten: <span id="balls-eaten">0</span></div>
        </div>
        <div id="instructions">
            <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move | 
            <kbd>Mouse</kbd> Look | 
            <kbd>Click</kbd> Eat/Bite | 
            <kbd>Hold Click</kbd> Pick Up | 
            <kbd>Release</kbd> Throw |
            <kbd>ESC</kbd> Pause
        </div>
    </div>

    <!-- Pause Menu -->
    <div id="pause-menu">
        <h2 style="font-family: 'Bangers', cursive; font-size: 4rem; color: #ff6b6b; margin-bottom: 2rem;">PAUSED</h2>
        <button class="pause-btn" id="resume-btn">RESUME</button>
        <button class="pause-btn" id="quit-btn">QUIT TO MENU</button>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Cannon-es Physics -->
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>

    <script>
        // ============================================
        // BALLMUNCHER GAME
        // ============================================

        // Menu confetti
        const confettiContainer = document.getElementById('menu-confetti');
        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#1dd1a1', '#f368e0'];
        
        for (let i = 0; i < 50; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti-piece';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
            confetti.style.animationDelay = Math.random() * 5 + 's';
            confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
            confettiContainer.appendChild(confetti);
        }

        // Game state
        let gameStarted = false;
        let isPaused = false;
        let ballsEaten = 0;
        let heldBall = null;
        let isHolding = false;
        let holdStartTime = 0;

        // Three.js setup
        let scene, camera, renderer;
        let playerBody, leftHand, rightHand;
        let balls = [];
        let confettiParticles = [];

        // Cannon.js physics
        let world;
        let playerPhysicsBody;
        let handBodies = [];
        let ballBodies = [];

        // Controls
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let euler = new THREE.Euler(0, 0, 0, 'YXZ');
        let isPointerLocked = false;

        // Face textures for balls
        const faceTypes = ['normal', 'happy', 'angry', 'scared', 'bitten'];

        // DOM elements
        const mainMenu = document.getElementById('main-menu');
        const gameContainer = document.getElementById('game-container');
        const pauseMenu = document.getElementById('pause-menu');
        const playBtn = document.getElementById('play-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const quitBtn = document.getElementById('quit-btn');
        const ballsEatenDisplay = document.getElementById('balls-eaten');

        // ============================================
        // INITIALIZATION
        // ============================================

        function initGame() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 10, 80);

            // Camera (First Person)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            gameContainer.insertBefore(renderer.domElement, gameContainer.firstChild);

            // Physics World
            world = new CANNON.World();
            world.gravity.set(0, -20, 0);
            world.broadphase = new CANNON.NaiveBroadphase();

            // Create environment
            createRoom();
            createPlayer();
            createBalls();
            createConfetti();
            createLighting();

            // Event listeners
            setupControls();

            // Start game loop
            animate();
        }

        // ============================================
        // ROOM CREATION
        // ============================================

        function createRoom() {
            const roomSize = 40;
            const wallHeight = 15;

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x2d2d44,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Floor physics
            const floorShape = new CANNON.Plane();
            const floorBody = new CANNON.Body({ mass: 0 });
            floorBody.addShape(floorShape);
            floorBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
            world.addBody(floorBody);

            // Walls with fun colors
            const wallColors = [0xff6b6b, 0x48dbfb, 0xfeca57, 0xff9ff3];
            const wallPositions = [
                { pos: [0, wallHeight/2, -roomSize/2], rot: [0, 0, 0] },
                { pos: [0, wallHeight/2, roomSize/2], rot: [0, Math.PI, 0] },
                { pos: [-roomSize/2, wallHeight/2, 0], rot: [0, Math.PI/2, 0] },
                { pos: [roomSize/2, wallHeight/2, 0], rot: [0, -Math.PI/2, 0] }
            ];

            wallPositions.forEach((wall, i) => {
                const wallGeometry = new THREE.PlaneGeometry(roomSize, wallHeight);
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: wallColors[i],
                    roughness: 0.6,
                    metalness: 0.1,
                    side: THREE.DoubleSide
                });
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.set(...wall.pos);
                wallMesh.rotation.y = wall.rot[1];
                wallMesh.receiveShadow = true;
                scene.add(wallMesh);

                // Wall physics
                const wallShape = new CANNON.Plane();
                const wallBody = new CANNON.Body({ mass: 0 });
                wallBody.addShape(wallShape);
                wallBody.position.set(...wall.pos);
                wallBody.quaternion.setFromEuler(0, wall.rot[1], 0);
                world.addBody(wallBody);
            });

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(roomSize, roomSize);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.9
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = wallHeight;
            ceiling.rotation.x = Math.PI / 2;
            scene.add(ceiling);

            // Add some decorative elements
            for (let i = 0; i < 20; i++) {
                const boxSize = Math.random() * 2 + 0.5;
                const boxGeometry = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
                const boxMaterial = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random() * colors.length)].replace('#', '0x'),
                    roughness: 0.4,
                    metalness: 0.6
                });
                const box = new THREE.Mesh(boxGeometry, boxMaterial);
                box.position.set(
                    (Math.random() - 0.5) * (roomSize - 5),
                    boxSize / 2,
                    (Math.random() - 0.5) * (roomSize - 5)
                );
                box.rotation.y = Math.random() * Math.PI;
                box.castShadow = true;
                box.receiveShadow = true;
                scene.add(box);

                // Box physics
                const boxShape = new CANNON.Box(new CANNON.Vec3(boxSize/2, boxSize/2, boxSize/2));
                const boxBody = new CANNON.Body({ mass: 0 });
                boxBody.addShape(boxShape);
                boxBody.position.copy(box.position);
                boxBody.quaternion.copy(box.quaternion);
                world.addBody(boxBody);
            }
        }

        // ============================================
        // PLAYER CREATION
        // ============================================

        function createPlayer() {
            // Player physics body (capsule approximated with sphere + cylinder)
            const playerShape = new CANNON.Sphere(0.5);
            playerPhysicsBody = new CANNON.Body({ 
                mass: 80,
                fixedRotation: true,
                linearDamping: 0.9
            });
            playerPhysicsBody.addShape(playerShape);
            playerPhysicsBody.position.set(0, 2, 5);
            world.addBody(playerPhysicsBody);

            // Visual pill body (visible when looking down)
            const bodyGroup = new THREE.Group();

            // Pill body
            const pillGeometry = new THREE.CapsuleGeometry(0.3, 0.8, 8, 16);
            const pillMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x48dbfb,
                roughness: 0.3,
                metalness: 0.7
            });
            playerBody = new THREE.Mesh(pillGeometry, pillMaterial);
            playerBody.position.y = -0.8;
            playerBody.castShadow = true;
            bodyGroup.add(playerBody);

            // Left hand
            const handGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const handMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xfeca57,
                roughness: 0.2,
                metalness: 0.8
            });
            
            leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.4, -0.3, -0.5);
            leftHand.castShadow = true;
            bodyGroup.add(leftHand);

            rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.4, -0.3, -0.5);
            rightHand.castShadow = true;
            bodyGroup.add(rightHand);

            camera.add(bodyGroup);
            scene.add(camera);

            // Hand physics
            const handShape = new CANNON.Sphere(0.15);
            
            const leftHandBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
            leftHandBody.addShape(handShape);
            world.addBody(leftHandBody);
            handBodies.push(leftHandBody);

            const rightHandBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC });
            rightHandBody.addShape(handShape);
            world.addBody(rightHandBody);
            handBodies.push(rightHandBody);
        }

        // ============================================
        // BALL CREATION
        // ============================================

        function createBalls() {
            const ballCount = 30;

            for (let i = 0; i < ballCount; i++) {
                createBall();
            }
        }

        function createBall(position = null) {
            if (!window.rateLimit()) return null;

            const radius = Math.random() * 0.5 + 0.3;
            const hasFace = Math.random() > 0.5;
            const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);

            // Ball mesh
            const ballGeometry = new THREE.SphereGeometry(radius, 32, 32);
            const ballMaterial = new THREE.MeshStandardMaterial({ 
                color: color,
                roughness: 0.2,
                metalness: 0.5
            });
            const ball = new THREE.Mesh(ballGeometry, ballMaterial);
            
            const pos = position || {
                x: (Math.random() - 0.5) * 30,
                y: Math.random() * 8 + 2,
                z: (Math.random() - 0.5) * 30
            };
            
            ball.position.set(pos.x, pos.y, pos.z);
            ball.castShadow = true;
            ball.receiveShadow = true;

            // Face for some balls
            if (hasFace) {
                const faceGroup = new THREE.Group();
                
                // Eyes
                const eyeGeometry = new THREE.SphereGeometry(radius * 0.15, 16, 16);
                const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const pupilGeometry = new THREE.SphereGeometry(radius * 0.08, 16, 16);
                const pupilMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-radius * 0.3, radius * 0.2, radius * 0.85);
                const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                leftPupil.position.set(-radius * 0.3, radius * 0.2, radius * 0.95);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(radius * 0.3, radius * 0.2, radius * 0.85);
                const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
                rightPupil.position.set(radius * 0.3, radius * 0.2, radius * 0.95);

                // Mouth (happy by default)
                const mouthGeometry = new THREE.TorusGeometry(radius * 0.2, radius * 0.03, 8, 16, Math.PI);
                const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, -radius * 0.2, radius * 0.85);
                mouth.rotation.x = Math.PI;

                faceGroup.add(leftEye, leftPupil, rightEye, rightPupil, mouth);
                ball.add(faceGroup);
                ball.userData.face = faceGroup;
                ball.userData.hasFace = true;
                ball.userData.faceState = 'happy';
            }

            ball.userData.radius = radius;
            ball.userData.originalRadius = radius;
            ball.userData.biteCount = 0;
            ball.userData.maxBites = Math.floor(radius * 10) + 2;

            scene.add(ball);
            balls.push(ball);

            // Ball physics
            const ballShape = new CANNON.Sphere(radius);
            const ballBody = new CANNON.Body({ 
                mass: radius * 2,
                linearDamping: 0.3,
                angularDamping: 0.3
            });
            ballBody.addShape(ballShape);
            ballBody.position.set(pos.x, pos.y, pos.z);
            
            // Random initial velocity
            ballBody.velocity.set(
                (Math.random() - 0.5) * 5,
                Math.random() * 3,
                (Math.random() - 0.5) * 5
            );
            
            world.addBody(ballBody);
            ballBodies.push(ballBody);
            ball.userData.physicsBody = ballBody;

            return ball;
        }

        // ============================================
        // CONFETTI
        // ============================================

        function createConfetti() {
            const confettiCount = 200;
            const confettiGeometry = new THREE.BufferGeometry();
            const positions = [];
            const confettiColors = [];

            for (let i = 0; i < confettiCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 40,
                    Math.random() * 15,
                    (Math.random() - 0.5) * 40
                );
                const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
                confettiColors.push(color.r, color.g, color.b);
            }

            confettiGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            confettiGeometry.setAttribute('color', new THREE.Float32BufferAttribute(confettiColors, 3));

            const confettiMaterial = new THREE.PointsMaterial({
                size: 0.2,
                vertexColors: true,
                transparent: true,
                opacity: 0.8
            });

            const confetti = new THREE.Points(confettiGeometry, confettiMaterial);
            confetti.userData.velocities = [];
            
            for (let i = 0; i < confettiCount; i++) {
                confetti.userData.velocities.push({
                    x: (Math.random() - 0.5) * 0.02,
                    y: -Math.random() * 0.05 - 0.02,
                    z: (Math.random() - 0.5) * 0.02
                });
            }

            scene.add(confetti);
            confettiParticles.push(confetti);
        }

        // ============================================
        // LIGHTING
        // ============================================

        function createLighting() {
            // Ambient light
            const ambient = new THREE.AmbientLight(0x404080, 0.5);
            scene.add(ambient);

            // Main directional light
            const mainLight = new THREE.DirectionalLight(0xffffff, 1);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 50;
            mainLight.shadow.camera.left = -25;
            mainLight.shadow.camera.right = 25;
            mainLight.shadow.camera.top = 25;
            mainLight.shadow.camera.bottom = -25;
            scene.add(mainLight);

            // Colored point lights for atmosphere
            const pointLight1 = new THREE.PointLight(0xff6b6b, 1, 30);
            pointLight1.position.set(-15, 10, -15);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x48dbfb, 1, 30);
            pointLight2.position.set(15, 10, 15);
            scene.add(pointLight2);

            const pointLight3 = new THREE.PointLight(0xfeca57, 1, 30);
            pointLight3.position.set(0, 12, 0);
            scene.add(pointLight3);
        }

        // ============================================
        // CONTROLS
        // ============================================

        function setupControls() {
            // Pointer lock
            gameContainer.addEventListener('click', () => {
                if (!isPaused && gameStarted) {
                    document.body.requestPointerLock();
                }
            });

            document.addEventListener('pointerlockchange', () => {
                isPointerLocked = document.pointerLockElement === document.body;
            });

            // Mouse movement
            document.addEventListener('mousemove', (e) => {
                if (!isPointerLocked || isPaused) return;

                euler.setFromQuaternion(camera.quaternion);
                euler.y -= e.movementX * 0.002;
                euler.x -= e.movementY * 0.002;
                euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, euler.x));
                camera.quaternion.setFromEuler(euler);
            });

            // Keyboard
            document.addEventListener('keydown', (e) => {
                if (!gameStarted) return;
                
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Escape': togglePause(); break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyD': moveRight = false; break;
                }
            });

            // Mouse click for eating/picking up
            document.addEventListener('mousedown', (e) => {
                if (!isPointerLocked || isPaused) return;
                if (!window.rateLimit()) return;

                isHolding = true;
                holdStartTime = Date.now();

                // Raycast to find ball
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

                const intersects = raycaster.intersectObjects(balls.filter(b => b.visible));

                if (intersects.length > 0) {
                    const hitBall = intersects[0].object;
                    const hitPoint = intersects[0].point;

                    // Check if close enough to grab
                    const distance = camera.position.distanceTo(hitBall.position);
                    if (distance < 5) {
                        heldBall = hitBall;
                    }
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (!isPointerLocked || isPaused) return;

                const holdDuration = Date.now() - holdStartTime;

                if (heldBall) {
                    if (holdDuration < 200) {
                        // Quick click = bite
                        biteBall(heldBall);
                    } else {
                        // Held and released = throw
                        throwBall(heldBall);
                    }
                    heldBall = null;
                }

                isHolding = false;
            });
        }

        // ============================================
        // BALL INTERACTIONS
        // ============================================

        function biteBall(ball) {
            if (!window.rateLimit()) return;

            ball.userData.biteCount++;

            // Create bite effect
            const biteDiv = document.createElement('div');
            biteDiv.className = 'bite-effect';
            biteDiv.textContent = 'ðŸ˜‹';
            biteDiv.style.left = (window.innerWidth / 2 + (Math.random() - 0.5) * 100) + 'px';
            biteDiv.style.top = (window.innerHeight / 2 + (Math.random() - 0.5) * 100) + 'px';
            document.body.appendChild(biteDiv);
            setTimeout(() => biteDiv.remove(), 500);

            // Shrink the ball
            const newRadius = ball.userData.originalRadius * (1 - ball.userData.biteCount / ball.userData.maxBites);
            
            if (newRadius <= 0.1 || ball.userData.biteCount >= ball.userData.maxBites) {
                // Ball fully eaten
                eatBall(ball);
            } else {
                // Shrink ball
                ball.scale.setScalar(newRadius / ball.userData.originalRadius);
                ball.userData.radius = newRadius;

                // Update physics body
                const physicsBody = ball.userData.physicsBody;
                if (physicsBody) {
                    physicsBody.shapes[0].radius = newRadius;
                    physicsBody.shapes[0].updateBoundingSphereRadius();
                }

                // Change face if has one
                if (ball.userData.hasFace && ball.userData.faceState !== 'scared') {
                    changeFace(ball, 'scared');
                }

                // Add bite mark visual
                addBiteMark(ball);
            }
        }

        function addBiteMark(ball) {
            const biteMarkGeometry = new THREE.SphereGeometry(ball.userData.radius * 0.3, 8, 8, 0, Math.PI, 0, Math.PI);
            const biteMarkMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8B4513,
                side: THREE.DoubleSide
            });
            const biteMark = new THREE.Mesh(biteMarkGeometry, biteMarkMaterial);
            
            // Position bite mark where camera is looking
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.negate();
            
            biteMark.position.copy(direction.multiplyScalar(ball.userData.radius * 0.9));
            biteMark.lookAt(0, 0, 0);
            
            ball.add(biteMark);
        }

        function changeFace(ball, state) {
            if (!ball.userData.face) return;

            ball.userData.faceState = state;
            
            // Remove old mouth
            const face = ball.userData.face;
            const oldMouth = face.children.find(c => c.geometry && c.geometry.type === 'TorusGeometry');
            if (oldMouth) face.remove(oldMouth);

            const radius = ball.userData.originalRadius;

            // Create new mouth based on state
            let mouthGeometry;
            if (state === 'scared') {
                // O-shaped scared mouth
                mouthGeometry = new THREE.TorusGeometry(radius * 0.15, radius * 0.03, 8, 16);
            } else if (state === 'angry') {
                // Frown
                mouthGeometry = new THREE.TorusGeometry(radius * 0.2, radius * 0.03, 8, 16, Math.PI);
            } else {
                // Happy smile
                mouthGeometry = new THREE.TorusGeometry(radius * 0.2, radius * 0.03, 8, 16, Math.PI);
            }

            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -radius * 0.2, radius * 0.85);
            
            if (state === 'scared') {
                mouth.rotation.x = Math.PI / 2;
            } else if (state === 'angry') {
                mouth.rotation.x = 0;
            } else {
                mouth.rotation.x = Math.PI;
            }

            face.add(mouth);
        }

        function eatBall(ball) {
            // Remove from scene
            scene.remove(ball);
            
            // Remove physics body
            const bodyIndex = ballBodies.indexOf(ball.userData.physicsBody);
            if (bodyIndex > -1) {
                world.removeBody(ball.userData.physicsBody);
                ballBodies.splice(bodyIndex, 1);
            }

            // Remove from array
            const ballIndex = balls.indexOf(ball);
            if (ballIndex > -1) {
                balls.splice(ballIndex, 1);
            }

            ballsEaten++;
            ballsEatenDisplay.textContent = ballsEaten;

            // Spawn new ball
            setTimeout(() => createBall(), 1000);
        }

        function throwBall(ball) {
            const physicsBody = ball.userData.physicsBody;
            if (!physicsBody) return;

            // Get throw direction from camera
            const throwDir = new THREE.Vector3();
            camera.getWorldDirection(throwDir);

            const throwForce = 30;
            physicsBody.velocity.set(
                throwDir.x * throwForce,
                throwDir.y * throwForce + 5,
                throwDir.z * throwForce
            );

            // Add spin
            physicsBody.angularVelocity.set(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );
        }

        // ============================================
        // GAME LOOP
        // ============================================

        function animate() {
            requestAnimationFrame(animate);

            if (!gameStarted || isPaused) return;

            const delta = 1 / 60;

            // Update physics
            world.step(delta);

            // Update player position
            if (isPointerLocked) {
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = 15;

                if (moveForward || moveBackward) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    forward.y = 0;
                    forward.normalize();
                    playerPhysicsBody.velocity.x = forward.x * direction.z * speed;
                    playerPhysicsBody.velocity.z = forward.z * direction.z * speed;
                }

                if (moveLeft || moveRight) {
                    const right = new THREE.Vector3();
                    camera.getWorldDirection(right);
                    right.y = 0;
                    right.normalize();
                    right.cross(new THREE.Vector3(0, 1, 0));
                    playerPhysicsBody.velocity.x += right.x * direction.x * speed;
                    playerPhysicsBody.velocity.z += right.z * direction.x * speed;
                }

                if (!moveForward && !moveBackward && !moveLeft && !moveRight) {
                    playerPhysicsBody.velocity.x *= 0.9;
                    playerPhysicsBody.velocity.z *= 0.9;
                }
            }

            // Sync camera to physics body
            camera.position.x = playerPhysicsBody.position.x;
            camera.position.y = playerPhysicsBody.position.y + 0.5;
            camera.position.z = playerPhysicsBody.position.z;

            // Update hand physics positions
            const leftHandWorld = new THREE.Vector3();
            leftHand.getWorldPosition(leftHandWorld);
            handBodies[0].position.set(leftHandWorld.x, leftHandWorld.y, leftHandWorld.z);

            const rightHandWorld = new THREE.Vector3();
            rightHand.getWorldPosition(rightHandWorld);
            handBodies[1].position.set(rightHandWorld.x, rightHandWorld.y, rightHandWorld.z);

            // Update ball visuals from physics
            balls.forEach((ball, i) => {
                if (ballBodies[i]) {
                    // If ball is being held, move it to hand
                    if (ball === heldBall && isHolding) {
                        const holdPos = new THREE.Vector3();
                        camera.getWorldDirection(holdPos);
                        holdPos.multiplyScalar(2);
                        holdPos.add(camera.position);
                        holdPos.y -= 0.3;
                        
                        ballBodies[i].position.set(holdPos.x, holdPos.y, holdPos.z);
                        ballBodies[i].velocity.set(0, 0, 0);
                    }

                    ball.position.copy(ballBodies[i].position);
                    ball.quaternion.copy(ballBodies[i].quaternion);

                    // Keep balls in bounds
                    if (ball.position.y < 0.5) {
                        ballBodies[i].position.y = 0.5;
                        ballBodies[i].velocity.y = Math.abs(ballBodies[i].velocity.y) * 0.5;
                    }

                    // Respawn if fell out of world
                    if (ball.position.y < -10) {
                        ballBodies[i].position.set(
                            (Math.random() - 0.5) * 30,
                            Math.random() * 8 + 5,
                            (Math.random() - 0.5) * 30
                        );
                        ballBodies[i].velocity.set(0, 0, 0);
                    }
                }
            });

            // Animate confetti
            confettiParticles.forEach(confetti => {
                const positions = confetti.geometry.attributes.position.array;
                const velocities = confetti.userData.velocities;

                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3] += velocities[i].x;
                    positions[i * 3 + 1] += velocities[i].y;
                    positions[i * 3 + 2] += velocities[i].z;

                    // Reset if fallen too low
                    if (positions[i * 3 + 1] < 0) {
                        positions[i * 3 + 1] = 15;
                        positions[i * 3] = (Math.random() - 0.5) * 40;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 40;
                    }
                }

                confetti.geometry.attributes.position.needsUpdate = true;
            });

            // Animate hands slightly
            const time = Date.now() * 0.003;
            leftHand.position.y = -0.3 + Math.sin(time) * 0.05;
            rightHand.position.y = -0.3 + Math.sin(time + Math.PI) * 0.05;

            renderer.render(scene, camera);
        }

        // ============================================
        // MENU FUNCTIONS
        // ============================================

        function startGame() {
            mainMenu.classList.add('hidden');
            gameContainer.classList.add('active');
            gameStarted = true;
            
            if (!scene) {
                initGame();
            }
        }

        function togglePause() {
            if (!gameStarted) return;

            isPaused = !isPaused;
            
            if (isPaused) {
                document.exitPointerLock();
                pauseMenu.classList.add('active');
            } else {
                pauseMenu.classList.remove('active');
            }
        }

        function quitToMenu() {
            isPaused = false;
            gameStarted = false;
            pauseMenu.classList.remove('active');
            gameContainer.classList.remove('active');
            mainMenu.classList.remove('hidden');
            document.exitPointerLock();
        }

        // Event listeners
        playBtn.addEventListener('click', startGame);
        resumeBtn.addEventListener('click', () => {
            pauseMenu.classList.remove('active');
            isPaused = false;
        });
        quitBtn.addEventListener('click', quitToMenu);

        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>

</html>
